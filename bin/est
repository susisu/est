#!/usr/bin/env node

/*
 * est
 * copyright (c) 2015 Susisu
 */

"use strict";

process.title = "est";

var fs   = require("fs");
var path = require("path");
var co   = require("co");

var est = require("..");

var PROGRAM_ENCODING           = "utf8";
var DEFAULT_EXTENSION_FILE     = "estenv.js";
var DEFAULT_EXTENSION_FULLNAME = path.resolve(DEFAULT_EXTENSION_FILE);

var program = require("commander");
var packageInfo = require("../package.json");
program.version(packageInfo["version"], "-v, --version")
    .usage("[options] ['prog' | -p progfile] [file...]")
    .option("-e, --encoding <code>", "set input file encoding (default = utf8)", "utf8")
    .option("-p, --program <file>", "read program from file")
    .option("-t, --transpose", "transpose output")
    .option("-x, --exponential", "output numbers in exponential notation")
    .option(
        "-E, --extension <file>", "load JavasSript extension (default = estenv.js)",
        (file, list) => { list.push(file); return list; }, []
    )
    .parse(process.argv);

if (program.args.length === 0 && !program["program"]) {
    program.help();
}

var main = co(function * () {
    var progfile, prog, files;
    // read program from file if --program is set
    if (program["program"]) {
        progfile = program["program"];
        prog     = yield readFile(program["program"], PROGRAM_ENCODING);
        files    = program.args;
    }
    else {
        progfile = "";
        prog     = program.args[0];
        files    = program.args.slice(1);
    }
    // parse and optimise
    var expr = est.parse(progfile, prog).optimise();
    // read data
    var data = yield Promise.all(files.map(file => readFile(file, program["encoding"])));
    // load extensions
    var extensions = yield loadExtensions(program["extension"]);
    // execute program
    var res = exec(expr, data, extensions);
    // output result
    var resStr = showData(res, program["transpose"], program["exponential"]);
    process.stdout.write(resStr + "\n");
}).catch(err => {
    console.error(String(err));
    process.exit(1);
});


function readFile(filename, option) {
    return new Promise((resolve, reject) =>
        fs.readFile(filename, option, (err, data) => {
            if (err) {
                reject(err);
                return;
            }
            resolve(data);
        })
    );
}

function access(filename, mode) {
    return new Promise((resolve, reject) => {
        fs.access(filename, mode, err => {
            if (err) {
                reject(err);
                return;
            }
            resolve();
        });
    });
}

function loadExtensions(files) {
    return co(function * () {
        var extensions = [];
        var extfullnames = files.map(file => path.resolve(file));
        if (extfullnames.indexOf(DEFAULT_EXTENSION_FULLNAME) === -1) {
            var defaultExt = false;
            try {
                yield access(DEFAULT_EXTENSION_FULLNAME, fs.R_OK);
                defaultExt = true;
            }
            catch (err) {
                // ignore
            }
            try {
                if (defaultExt) {
                    extensions.push({
                        file     : DEFAULT_EXTENSION_FILE,
                        extension: require(DEFAULT_EXTENSION_FULLNAME)
                    });
                }
            }
            catch (err) {
                throw new Error("in '" + DEFAULT_EXTENSION_FILE + "':\n" + String(err));
            }
        }
        files.forEach(file => {
            try {
                extensions.push({
                    file     : file,
                    extension: require(path.resolve(file))
                });
            }
            catch (err) {
                throw new Error("in '" + file + "':\n" + String(err));
            }
        });
        return extensions;
    });
}

function exec(expr, data, extensions) {
    var env = Object.create(est.prelude);
    // load JavaScript extension
    extensions.forEach(ext => {
        if (typeof ext.extension !== "function") {
            throw new Error("extension '" + ext.file + "' is invalid");
        }
        try {
            ext.extension(est, env);
        }
        catch (err) {
            throw new Error("in '" + ext.file + "':\n" + String(err));
        }
    });
    // read table data
    data.forEach((d, i) => {
        var table  = readTable(d);
        var tableT = transpose(table);
        env["$$T" + (i + 1).toString()] = table;
        env["$$"  + (i + 1).toString()] = tableT;
        if (i === 0) {
            var numCols = tableT.length;
            for (var col = 0; col < numCols; col++) {
                env["$" + (col + 1).toString()] = tableT[col];
            }
        }
    });
    // evaluate
    return expr.eval(env);
}

function readTable(data) {
    var table = data.split(/\n+/)
        .map(line => line.trim())
        .filter(line => line.length > 0 && line[0] !== "#")
        .map(line => line.split(/\s+/).map(x => parseFloat(x)));
    var height = table.length;
    var width  = 0;
    var i, j;
    // calculate table width
    for (i = 0; i < height; i++) {
        if (table[i].length > width) {
            width = table[i].length;
        }
    }
    // fill empty field with NaN
    for (i = 0; i < height; i++) {
        for (j = 0; j < width; j++) {
            if (table[i][j] === undefined) {
                table[i][j] = NaN;
            } 
        }
    }
    return table;
}

function transpose(table) {
    var height = table.length;
    var width  = 0;
    var i, j;
    // calculate table width
    for (i = 0; i < height; i++) {
        if (table[i].length > width) {
            width = table[i].length;
        }
    }
    // create transposed table
    var t = [];
    for (i = 0; i < width; i++) {
        t[i] = [];
        for (j = 0; j < height; j++) {
            if (table[j][i] === undefined) {
                t[i][j] = NaN;
            }
            else {
                t[i][j] = table[j][i];
            }
        }
    }
    return t;
}

function showData(data, transp, exp) {
    var t = est.value.typeOf(data);
    switch (t) {
    case est.value.Type.VECTOR:
        var r = rank(data);
        switch (r) {
        case 1: // simple vector
            return transp
                ? data.map(x => showData(x, transp, exp)).join("\t")
                : data.map(x => showData(x, transp, exp)).join("\n")
        case 2: // matrix
            return (transp ? data : transpose(data)).map(row =>
                row.map(x => showData(x, transp, exp)).join("\t")
            ).join("\n");
        default:
            throw new Error("invalid data: expected simple vector or matrix, actual more complex structure");
        }
    case est.value.Type.NUMBER:
        return exp ? data.toExponential() : data.toString();
    case est.value.Type.FUNCTION:
        throw new Error("invalid data: unexpected " + est.value.Type.FUNCTION);
    default:
        return data.toString();
    }
}

function rank(data) {
    var t = est.value.typeOf(data);
    if (t === est.value.Type.VECTOR) {
        var cr = data.length === 0 ? 0 : rank(data[0]);
        for (var i = 1; i < data.length; i++) {
            if (rank(data[i]) !== cr) {
                throw new Error("invalid data structure");
            }
        }
        return cr + 1;
    }
    else {
        return 0;
    }
}
